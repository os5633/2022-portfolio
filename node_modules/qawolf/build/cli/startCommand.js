"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildStartCommand = void 0;
const better_opn_1 = __importDefault(require("better-opn"));
const commander_1 = require("commander");
const kleur_1 = require("kleur");
const constants_1 = require("./constants");
const getDocker_1 = __importDefault(require("./getDocker"));
const getRunnerContainer_1 = __importDefault(require("./getRunnerContainer"));
const pullRunnerImage_1 = __importDefault(require("./pullRunnerImage"));
const buildStartCommand = () => {
    const command = new commander_1.Command("start")
        .option("-b, --background", `run QA Wolf in the background. Use \`${constants_1.CLI_NAME} stop\` to stop it.`)
        .option("-v, --verbose", "enable extra logging")
        .description("✨ Start a QA Wolf runner service to record or run tests")
        .action(async ({ background, verbose }) => {
        console.log(kleur_1.bold("\n🐺  Welcome to QA Wolf!"));
        const { docker, dockerIsRunning } = await getDocker_1.default();
        if (!dockerIsRunning)
            return;
        await pullRunnerImage_1.default(docker, verbose);
        console.log("\n    Starting");
        // Get a reference to already running runner container if possible
        const containerResponse = await getRunnerContainer_1.default(docker);
        let { container } = containerResponse;
        // Otherwise create the runner container
        if (!container) {
            try {
                container = await docker.createContainer({
                    ExposedPorts: {
                        "26367/tcp": {},
                    },
                    HostConfig: {
                        AutoRemove: true,
                        PortBindings: {
                            "26367/tcp": [
                                {
                                    HostPort: "26367",
                                },
                            ],
                        },
                    },
                    Image: constants_1.DOCKER_IMAGE_NAME,
                    name: constants_1.DOCKER_CONTAINER_NAME,
                });
            }
            catch (error) {
                console.error("Error creating container:", error);
                return;
            }
        }
        if (!containerResponse.isRunning) {
            try {
                await container.start();
            }
            catch (error) {
                console.error("Error starting container:", error.message);
                return;
            }
        }
        better_opn_1.default(constants_1.QAWOLF_URL);
        console.log(`\n🎉  All set - let's get testing!`);
        console.log(`\n    (If the QA Wolf app did not open, go to ${constants_1.QAWOLF_URL} in a web browser.)`);
        if (background) {
            console.log(`\n    When you are done, run \`${constants_1.CLI_NAME} stop\` to stop QA Wolf.\n`);
        }
        else {
            console.log("\n    When you are done, press CTRL+C to stop QA Wolf.\n");
            // These things cause leaking in Jest tests, so do them only when not running tests
            if (typeof jest === "undefined") {
                process.on("SIGINT", async () => {
                    console.log("\n    Stopping");
                    try {
                        await container.stop();
                        console.log("\n    Stopped\n");
                    }
                    catch (error) {
                        if (error.message.includes("No such container")) {
                            console.log("\n    Stopped\n");
                        }
                        else {
                            console.error(error.message);
                        }
                    }
                    process.exit(0);
                });
                setInterval(() => {
                    // Keeping Node process alive until SIGINT
                }, 1 << 30);
            }
        }
    });
    return command;
};
exports.buildStartCommand = buildStartCommand;
//# sourceMappingURL=startCommand.js.map