"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_retry_1 = __importDefault(require("async-retry"));
const axios_1 = __importDefault(require("axios"));
const kleur_1 = require("kleur");
const qaWolfUrl = process.env.QAWOLF_URL || "https://www.qawolf.com";
const createSuite = async ({ branch, environment, tags, triggerId, variables, }) => {
    var _a;
    const suitesUrl = new URL("/api/suites", qaWolfUrl).href;
    try {
        const { data: { id, url }, } = await axios_1.default.post(suitesUrl, {
            branch: branch || null,
            environment,
            tags,
            trigger_id: triggerId,
            variables,
        }, { headers: { authorization: process.env.QAWOLF_API_KEY } });
        console.log("Created suite, see details at", url);
        return { id, url };
    }
    catch (error) {
        console.log(kleur_1.red(`Error creating suite: ${(_a = error.response) === null || _a === void 0 ? void 0 : _a.data}`));
        process.exit(1);
    }
};
const ensureApiKey = () => {
    if (!process.env.QAWOLF_API_KEY) {
        console.log(kleur_1.red("Error: must set QAWOLF_API_KEY environment variable"));
        process.exit(1);
    }
};
const waitForSuite = async (suiteId) => {
    console.log("Waiting for tests to run...");
    const suiteUrl = new URL(`/api/suites/${suiteId}`, qaWolfUrl).href;
    const intervalMs = 10 * 1000; // 10 seconds
    const timeoutMs = 30 * 60 * 1000; // 30 minutes
    let timeout = false;
    const requestPromise = async_retry_1.default(async () => {
        if (timeout)
            return;
        const { data } = await axios_1.default.get(suiteUrl, {
            headers: { authorization: process.env.QAWOLF_API_KEY },
        });
        if (!data.is_complete)
            throw new Error("suite not complete");
        return data.status;
    }, {
        factor: 1,
        maxTimeout: intervalMs,
        minTimeout: intervalMs,
        retries: Math.round(timeoutMs / intervalMs),
    });
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
            timeout = true;
            reject(new Error("Suite not complete"));
        }, timeoutMs);
    });
    return Promise.race([requestPromise, timeoutPromise]);
};
async function runTests({ branch, environment, tags, triggerId, variables, wait, }) {
    const tagsMessage = tags ? ` for tags ${tags}` : "";
    console.log(kleur_1.bold(`\n🐺 Run QA Wolf tests${tagsMessage}`));
    ensureApiKey();
    const { id: suiteId, url } = await createSuite({
        branch,
        environment,
        tags,
        triggerId,
        variables,
    });
    if (!wait)
        return;
    const status = await waitForSuite(suiteId);
    const colorFn = status === "fail" ? kleur_1.red : kleur_1.green;
    console.log(colorFn(`🐺 Complete, suite ${status}ed: ${url}`));
    process.exit(status === "fail" ? 1 : 0);
}
exports.default = runTests;
//# sourceMappingURL=runTests.js.map